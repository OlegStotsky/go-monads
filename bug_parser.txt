package main

import (
	"fmt"
)

type Unit struct{}
type Func(type U, V) func(U) V

var UnitVar = struct{}{}

type Pair(type F, S) struct {
    First F
    Second S
}

type State(type S, A) interface {
    RunState(S) (A, S)
}

type StateImpl(type S, A) struct {
    f func(S) (A, S)
}

func (s StateImpl(S, A)) RunState(state S) (A, S) {
   return s.f(state)
}

func Return(type S, A)(x A) State(S, A){
     return StateImpl(S, A){f: func(s S) (A, S) { return x, s }}
}


func Map(type S, A, B)(s State(S, A), mapF Func(A, B)) State(S, B) {
     return StateImpl(S, B){f: func(state S) (B, S) {
	a, newState := s.RunState(state)
	return mapF(a), newState
 }}
}

func FlatMap(type S, A, B)(s State(S, A), mapF Func(A, State(S, B))) State(S, B) {
     return StateImpl(S, B){f: func(state S) (B, S) {
	a, newState := s.RunState(state)
	result := mapF(a)
	return result.RunState(newState)
 }}
}

func Get(type S)() State(S, S) {
     return StateImpl(S, S){f: func(state S) (S, S) {
         return state, state
     }}
}

func Put(type S, A)(newState S) State(S, Unit){
     return StateImpl(S, Unit){f: func(S) (Unit, S) { return struct{}{}, newState }}
}


type Stack(type S) interface {
    Head() S
    Tail() Stack(S)
}

type Cons(type S) struct {
    head S
    tail Stack(S)
}

type Nil(type S) struct{}

func (cons Cons(S)) Head() { return cons.head }
func (cons Cons(S)) Tail() { return cons.tail }

func (cons Nil(S)) Head() { return nil }
func (cons Nil(S)) Tail() { return nil }

func Push(int x) State(Stack(int), Unit) {
   curState := Get(Stack(int))
   updatedState := Map(Stack(int), Stack(int), Stack(int))(curState, func(s Stack(Int)) Stack(Int) { return Cons{head: x, tail: s}  } )
   FlatMap(Stack(int), Stack(int), Unit)(updatedState, Put(Stack(int), Stack(int)))
}

func main(){

    fmt.Println(2)
}